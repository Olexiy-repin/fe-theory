<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Модуль 11</title><link rel="stylesheet" href="../css/styles.min.css?t=1584781054409"><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><script async src="../scripts/prism.js?t=1584781054409"></script></head><body class="theory-page"><div class="wrapper"><article><header><h1>Модуль 11 - Теорія</h1><!-- ============================== page-navigator =============================================  --><nav class="table-of-contents" id="main-nav"><ol class="page-nav"><li><a href="#scss">CSS препроцесори: SASS</a></li><li><a href="#automation">Введення в автоматизацію</a></li><li><a href="#a11y-html">Пишемо HTML, не забуваючи про доступність</a></li><li><a href="#a11y-css">Пишемо CSS, не забуваючи про доступність</a></li><li><a href="#microdata">Microdata</a></li></ol></nav><!-- ============================== end page-navigator =============================================  --></header><!-- ======================== SASS/SCSS =========================== --><section><h2 id="scss">CSS препроцесори: SASS</h2><p>Великий файл CSS складно писати і важко підтримувати. Для поліпшення організації, написання і підтримки коду CSS створені препроцесори. Найбільшу і заслужену популярність отримав препроцесор <a href="http://sass-lang.com/" target="_blank"><code>SASS</code> </a>і його новий синтаксис <code>SCSS</code>.</p><p>Його значення настільки велике, що найбільш важливі ідеї, реалізовані в цих препроцесорів, поступово проникають в стандарт CSS, як наприклад змінні або міксини.</p><p>SASS і SCSS це особливі типи даних, які перетворюються в CSS спеціальним компілятором. Між собою ці два синтаксису розрізняються лише візуально. SASS для опису вкладеності використовує прогалини, а синтаксис SCSS збігається з CSS. Іншими словами файл CSS не буде прочитаний інтерпретатором SASS, а SCSS вважатиме такий файл дійсним. З цієї причини найбільш комфортним буде перехід на SCSS.</p><p>Способів компіляції з SASS / SCSS в CSS досить багато. Для вивчення варто використовувати <code>codepen.io</code>. У цьому онлайн редакторі досить легко налаштувати вибір препроцесора і в один клік переглядати результат компіляції.</p><img src="../images/module-11/sass-pen.png" alt="" style="display: block; width: 80%; margin: auto; margin-bottom: 20px;"><p>Розглянемо найпопулярніші особливості SASS, освоїти які для подальшого застосування можна за кілька годин.</p><h3>Variables</h3><p>Однією з найпростіших, і в той же час потужних особливостей препроцесорів, є змінні і можливість здійснювати операції з ними. Синтаксис оголошення змінної знак <code>$</code> перед ім'ям. Потім це ім'я використовується в якості значення.</p><pre class="language-css"><code>$main-color: #888;
$width: 100%;

.menu {
  color: $main-color;
  width: $width - 20%;
}</code></pre><p>Буде скомпільовано в наступний CSS.</p><pre class="language-css"><code>.menu {
  color: #888;
  width: 80%;
}</code></pre><h3>Вкладені селектори (Nesting)</h3><p>Подібно вкладеності тегів в HTML, всередині SASS можна вкладати одне правило в інше.</p><pre class="language-css"><code>.menu {
  color: #888;
  width: 80%;
  .menu__item {
    background-color: #fff;
    .menu__link {
      color: #000;
    }
  }
}</code></pre><p>Цей SASS код буде скомпільовано в наступний CSS.</p><pre class="language-css"><code>.menu {
  color: #888;
  width: 80%;
}

.menu .menu__item {
  background-color: #fff;
}

.menu .menu__item .menu__link {
  color: #000;
}</code></pre><h3>Конкатенація (оператор &amp;)</h3><p>Оператор <code>&amp;</code> змушує компілятор вказати повний шлях до селектору, "зшиваючи" імена батьківських селектор.</p><pre class="language-css"><code>.menu {
  color: #888;
  width: 80%;
  &amp;__item {
    background-color: #fff;
  }
  &amp;__link {
    color: #000;
    &amp;:hover {
      color: #ff5722;
    }
  }
}</code></pre><p>Цей SASS код буде скомпільовано в наступний CSS.</p><pre class="language-css"><code>.menu {
  color: #888;
  width: 80%;
}

.menu__item {
  background-color: #fff;
}

.menu__link {
  color: #000;
}

.menu__link:hover {
  color: #ff5722;
}</code></pre><h3>Placeholder selector</h3><p>Часто буває ситуація, коли один і той же набір правил застосовується неодноразово. Для таких випадків можна задати шаблон - довільне ім'я селектора з обов'язковим символом <code>%</code> на початку, наприклад <code>%button</code>, і потім всередині фігурних дужок перерахувати властивості і значення.</p><p>Для додавання цього шаблону до селектору досить додати <code>@extend %button;</code> без двокрапки.</p><pre class="language-css"><code>%main-set {
  color: #888;
  width: 80%;
}

.menu {
  @extend %main-set;
}</code></pre><p>Буде скомпільовано в наступний CSS</p><pre class="language-css"><code>.menu {
  color: #888;
  width: 80%;
}</code></pre><h3>Data Types</h3><p>У SASS є 7 типів даних, найбільш цікаві з яких це:</p><ul><li><code>numbers</code> - числа, цілі і з плаваючою точкою (1.2, 13, 10px)</li><li><code>colors</code> - значення кольору в будь-якій формі записи зрозумілою браузеру,</li><li><code>strings</code> - рядки ( "текст", "в лапках ')</li><li><code>list</code> - перерахування значень (20px 15px 10px 5px)</li><li><code>map</code> - пари "ключ: значення"</li></ul><p>Над усіма типами даних можна проводити допустимі для цього типу даних операції і застосовувати до них спеціальні функції. Повний список всіх операцій можна знайти в документації. Зробимо невеликий огляд найбільш популярних.</p><h4>numbers</h4><p>Арифметичні операції <code>+, -, *, /</code> і залишок від ділення по модулю <code>%</code>.<br><code>960px % 11 + 20</code> одно <code>23px</code></p><h4>colors</h4><p>Всі ті ж арифметичні операції. Застосовуються до кожного кольору окремо. Альфа-канал не схильний до арифметичним перетворенням. Його змінюють за допомогою функцій <code>opacify</code> і <code>transparentize</code>.<br>#010203 * 2 перетворюється в #020406, а transparentize(#123abc, 0.2) перетворюється в rgba(18, 58, 188, 0.8)</p><h4>strings</h4><p>Доступна тільки операція конкатенації (додавання) з деякими особливостями. А саме - буде результат конкатенації в лапках чи ні залежить від того в лапках чи ні перший доданок.<br>"Arial" + Bold створить рядок "Arial Bold", а sans- + "serif" створить рядок без лапок sans-serif</p><h4>list і map</h4><p>Не мають операцій, але мають набір функцій.</p><h3>Control Directives &amp; Expressions</h3><p>SASS має директиви, що дозволяють створювати розгалуження і цикли, використання яких це просунутий рівень: <code>@if</code>, <code>@for</code>, <code>@each</code>.</p><h3>Mixin</h3><p>На особливу увагу заслуговують міксини. Вони дозволяють створювати готові набори css властивостей, але з різними значеннями, в залежності від отриманих аргументів при виклику міксина.</p><p>Миксин оголошується за допомогою директиви <code>@mixin</code> і імені міксина. Далі можуть йти параметри в круглих дужках (необов'язково) і в фігурних дужках йде опис властивостей і значень.</p><p>Використовується миксин також просто. Директива <code>@include</code> з ім'ям міксина, а також аргументами (якщо були задані параметри) викликає всередині фігурних дужок селектора все властивості, які були оголошені в Міксини. А аргументи міксина стають значеннями.</p><pre class="language-css"><code>@mixin main-padding($main-width) {
  padding: ($main-width / 20) ($main-width / 25);
}

div {
  @include main-padding(960px);
}</code></pre><p>Буде скомпільовано в наступний CSS.</p><pre class="language-css"><code>div {
  padding: 48px 38.4px;
}</code></pre><p>Міксини можна використовувати для створення семантичного модульної сітки, тобто сітки, що не використовує класи. Замість додавання класів в html до селекторам в SASS додаються міксини.</p><p>Прикладом такої семантичного сітки є фреймворк <code>Susy</code>, а тут <a href="https://css-tricks.com/build-web-layouts-easily-susy/" target="_blank">приклад</a> заміни несемантичної сітки на семантичну за допомогою цього фреймворка.</p><p>Не менш важливо і те, що міксини - це готові рішення, які легко впроваджувати в своєму коді. І співтовариство підготувало колекції таких Міксини. Найбільш популярною колекцією SASS Міксини є <a href="http://bourbon.io/" target="_blank">Bourbon</a>. Хороший огляд про цю колекцію можна подивитися <a href="https://webdesign.tutsplus.com/ru/tutorials/introducing-bourbon-lightweight-sass-mixins-and-more--cms-24733" target="_blank">тут.</a></p><h3>Project Structure</h3><p>C допомогою SASS можна розбити код на окремі директорії і файли відповідно до логіки проекту. Існує безліч способів зробити це. У наведеному прикладі демонструється загальний принцип.</p><p>В директорії <code>src/sass</code> знаходиться файл <code>main.scss</code>. Після компіляції цей файл перетворюється в <code>main.css</code> і буде поміщений в директорію з файлами для розміщення на сервері хостингу. Інші файли в директорії <code>src/sass</code> починаються з символу підкреслення <code>_</code>. Цей символ перед ім'ям файлу забороняє компілятору створювати ці файли після перетворення. Код з цих файлів буде розміщуватися всередині файлу <code>main.scss</code> завдяки імпорту вмісту. Синтаксис імпорту складається з команди <code>@import</code> і шляхи до файлу в подвійних лапках, без вказівки символу підкреслення.</p><img src="../images/module-11/sass-structure.png" alt=""><p>Про архітекруту SASS проекту можна прочитати <a href="http://prgssr.ru/development/estetichnyj-sass-chast-1-arhitektura-i-organizaciya.html" target="_blank">тут</a>.</p><h3>Висновок</h3><p>SASS є фактично стандартом в індустрії. За період більше 10 років цей препроцесор довів перевагу над конкурентами. Наприклад, <code>Bootstrap 4</code> перейшов з <code>Less</code> на <code>Sass</code>.</p><a href="https://sass-scss.ru/documentation/" target="_blank">Документація SASS російською</a></section><!-- AUTOMATION --><section><h2 id="automation">Введення в атоматизацію</h2><p>Front-end розробка стає, як і традиційна Back-end розробка, все комплексна і мудріша. Безліч проектів потребують більшої, ніж банальна закачування пари JS і CSS файлів по FTP. Зараз ми можемо спостерігати так званий процес складання front-end, який може включати компіляцію CSS препроцесорів, мініфікацію файлів, запуск лінтерів і багато іншого. Ці складальні завдання і процеси координуються такими інструментами як <code>Gulp</code> або <code>Grunt</code>.</p><p>Щоб впоратися з цією складністю, ми можемо використовувати інструмент автоматизації робочого процесу, який працює як конвеєр, виконуючи рутинні завдання за нас. Комп'ютери дуже хороші, коли їм дають список речей, які потрібно зробити, і виконувати їх абсолютно однаково кожен раз.</p><p><strong>Gulp</strong> - це інструмент, який допомагає автоматизувати рутинні завдання веб-розробки. Він призначений для вирішення таких завдань, як:</p><ul><li>Створення веб-сервера і автоматичне перезавантаження сторінки в браузері при збереженні коду.</li><li>Стеження за змінами в файлах проекту.</li><li>Використання різних JavaScript, CSS і HTML препроцесорів (Sass, Pug і т.д.).</li><li>Мініфікація CSS і JS коду, а також, оптимізація та конкатенація окремих файлів проекту в один.</li><li>Автоматичне створення Вендорний префіксів для CSS.</li><li>Управління файлами і папками в рамках проекту - створення, видалення, перейменування.</li><li>Робота з зображеннями - стиснення, створення спрайтів.</li><li>та багато іншого...</li></ul><p>Можна з упевненістю сказати, що Gulp і безліч утиліт, написаних для нього, підходять для вирішення практично будь-якої задачі при розробці проекту будь-якої складності - від невеликого сайту до великого проекту.</p><div class="note"><p>Для глибокого розуміння написання логіки конфігурації процесу автоматизації необхідне знання JavaScript. Однак використовувати вже готове рішення вкрай просто. Саме тому для курсу HTML / CSS була підготовлена ​​Gulp збірка дозволяє автоматизувати процес верстки.</p></div><h3>Підготовка</h3><p>Перше що необхідно зробити це встановити <code>NodeJS</code>, це легка і ефективна Виконавча JavaScript.</p><p>Щоб встановити останню версію NodeJS, перейдіть на <a href="https://nodejs.org/en/" target="_blank">офіційну веб-сторінку </a>. Просто скачайте інсталятор (LTS версію) і дотримуйтесь вказівок, досить просто натискати <code>Next</code>. Разом з <code>NodeJS</code> буде встановлений менеджер пакетів <code>npm</code>. Коли NodeJS встановиться, ви можете використовувати команду <code>node</code> в консолі:</p><figure><img src="../images/module-11/node-ver.png" alt="node version"><figcaption>Версія NodeJS на момент написання даного модуля</figcaption></figure><h3>Використання</h3><p>Для початку скачайте <a href="https://github.com/axZerk/gulp-starter-kit" target="_blank">цей репозиторій</a> як архів. Це і є та сама збірка для автоматизації верстки.</p><img src="../images/module-11/gulp-start-1.png" alt=""><p>Далі необхідно виконати всього кілька простих кроків:</p><ul><li>Перейменувати папку <code>gulp-starter-kit</code> ім'ям свого проекту.</li><li>В консолі, з правами адміністратора, перейти в корінь проекту, на рівень де лежать папки <code>src</code> і <code>dist</code>.</li><li>В консолі виконати команду <code>npm i</code>. Це встановить всі необхідні залежності збірки.</li><li>Почекати поки встановлюються всі залежності, це може зайняти різний час в залежності від якості інтернету і потужності комп'ютера.</li><li>Після закінчення установки, так само з консолі, перебуваючи в корені проекту, запустити збірку командою <code>npm start</code>.</li></ul><div class="note"><p>Буде додана папка <code>node_modules</code>, це папка в якій зберігаються всі встановлені інструменти. Не знімайте її, вона необхідна для роботи збірки.</p></div><p>В папці <code>src</code> знаходяться <code>вихідні</code>, це робочі файли в яких ви пишете <code>HTML</code> і <code>SASS</code> код, в файлі <code>index.html</code> і папці <code>src/sass/styles.scss</code> відповідно. Картинки додавайте в папку <code>src/img</code>, а шрифти в <code>src/fonts</code>.</p><p>При кожному збереженні або додаванні файлу, все буде оброблено <code>Gulp</code> і результат переміститься в папку <code>dist</code>. Там буде вже скомпілірований css, проведена мініфікація і додані Вендорні префікси. Так само буде автоматично запущено веб сервер, який "роздає" вже готові для браузера файли з папки <code>dist</code>, а так само автоматично оновлює сторінку в браузері при кожному збереженні файлів в папці <code>src</code>.</p><div class="warn"><p>Не видаляйте нічого що не входить в папки <code>src</code> або <code>dist</code>.</p></div></section><!-- SECTION --><section><h2 id="a11y-html">Пишемо HTML, не забуваючи про доступність</h2><p>Коли ви створюєте свій перший веб-сайт, то найвищим пріоритетом є створення контенту в інтернеті. Вас не турбують зручність використання, доступність, продуктивність, сумісність з браузерами. А з чого б вам про це хвилюватися? - аби працювало.</p><p>Звичайно ж, це до того, як ви станете професійним веб-розробником, зіткнетеся з реаліями і ваше уявлення про важливі речі зміниться. Ви почнете оптимізувати свої сайти під всі основні браузери замість того, щоб диктувати користувачу, що йому використовувати для відвідування сайту.</p><p>Ви почнете піклуватися і про підтримку різних девайсів. Розробляти сайти для різних типів пристроїв і браузерів прекрасно, але досить марно, якщо сайт дуже повільний. З цієї причини доведеться вивчити все, що стосується критичного CSS, індексів швидкості, завантаження шрифтів, CDN і тому подібного.</p><!-- SUB SECTION --><h3>Знайомство з доступністю (a11y)</h3><p>Швидкий, чуйний, що працює у всіх браузерах сайт нічого не варто, якщо по ньому не можна пересуватися за допомогою клавіатури або якщо його не можуть відвідати люди з обмеженими можливостями. Але доступність - це не просто ще один пункт в списку вимог до сайту. Доступність лежить в основі того, чим займаються веб-дизайнери та розробники і варто ставитися до неї саме так.</p><p>Не сприймайте даний матеріал як чек-лист, скоріше як відправну точку, адже матеріалу дійсно багато. Почніть застосовувати деякі з цих прийомів і рад в своїй розробці і, це послужить мотивацією для подальшого вивчення теми і прояви ще більшої турботи по відношенню до ваших користувачам. Все, що ви створюєте, марно, якщо воно недоступне.</p><!-- SUB SECTION --><h3>Важливо правильно вказати мову документа</h3><p>Вказуючи браузеру, якою мовою написаний документ, ви отримаєте багато переваг. Це добре для SEO, це допомагає плагинам-перекладачам і браузерам правильно визначити мову і словник. Правильне вказівку мови в HTML допомагає допоміжним технологіям вибрати правильний голосовий профіль або набір символів. Ще <a href="http://adrianroselli.com/2015/01/on-use-of-lang-attribute.html" target="_blank" rel="noopener">кілька плюсів</a> використання атрибута <code>lang</code>.</p><script type="text/plain" class="language-markup"><html lang="ru">
…
</html></script><div class="note"><p>Подивіться <a href="https://youtu.be/ox5QVbZSPBk" target="_blank" rel="noopener">демонстрацію роботи атрибута</a> lang на YouTube.</p></div><p>Якщо всередині документа зустрічаються кілька мов, то ви можете використовувати атрибут <code>lang</code> для окремих тегів .</p><script type="text/plain" class="language-markup"><p>В воздухе витало <i lang="fr" class="idiomatic">je ne sais quoi</i>.</p></script><div class="note"><p>Завжди перевіряйте щоб мова була вказана вірно. <a href="https://youtu.be/0uzxu9dQnuU" target="_blank" rel="noopener">Відео</a>, що ілюструє що станеться, якщо ви неправильно використовуєте атрибут <code>lang</code>.</p></div><!-- SUB SECTION --><h3>Можна ховати контент за допомогою атрибута hidden</h3><p>Якщо ви хочете приховати контент візуально і від екранних читалок, то використовуйте атрибут <code>hidden</code>. Підтримка атрибута <code>hidden</code> в браузерах відмінна, за винятком <code>IE10</code> і нижче. Ви можете забезпечити підтримку старих браузерів, просто додавши в CSS фоллбек.</p><pre class="language-css"><code>[hidden] {
  display: none;
}</code></pre><h3>Іноді корисніше додати порожній атрибут alt для картинки</h3><p>Якщо картинка є тематичної, використовуйте <code>alt</code> для короткого опису цього самого контенту і функціоналу. Коли ви будете це робити, то не розпочинайте опис з «picture / image / image of ...» бо екранна читалка сама скаже про те, що це за елемент.</p><p>Якщо зображення декоративне або не містить цінної інформації, подумайте про те, щоб винести його в CSS і реалізувати за допомогою <code>background-image</code>. Якщо ви повинні / хочете реалізувати його в HTML, то не видаляйте атрибут <code>alt</code>, просто залиште його порожнім.</p><script type="text/plain" class="language-markup"><img src="decorative_image.jpg" alt=""></script><div class="note"><strong>Важливо, щоб ви не опускали атрибут alt.</strong><p>Відсутність цього атрибута означає, що зображення є ключовою частиною контенту, але для нього немає текстового еквівалента. Якщо ж значення атрибута - порожній рядок, це означає, що зображення не є ключовою частиною контенту; тоді невізуальні браузери мають право зовсім його не відображати.</p></div><!-- SUB SECTION --><h3>Якщо потрібна кнопка, використовуй елемент button</h3><p>Коротко кажучи, вам завжди слід віддавати перевагу нативним HTML-елементів (якщо вони є) перед власними емуляції. Наприклад, якщо вам потрібна кнопка, то використовуйте елемент <code>button</code> замість <code>div</code>.</p><p>Кнопки мають безліч переваг / важливих функцій. наприклад:</p><ul><li>Можливість фокусування</li><li>Клікабельність (мишкою або клавіатурою)</li><li>Екранні читалки ідентифікують їх як кнопки</li></ul><p>Роб Додсон виконав відмінну роботу, пояснюючи переваги фактичної <code>button</code> над <code>div</code>. Дивіться епізод <a href="https://youtu.be/CZGqnp06DnI?list=PLNYkxOF6rcICWx0C9LVWWVqvHlYJyqw7g" target="_blank" rel="noopener">A11ycasts «Just use button»</a> для отримання більш детальної інформації та прикладів. Якщо ви не впевнені, що використовувати в конкретному випадку - кнопку або посилання - почитайте <a href="https://marcysutton.com/links-vs-buttons-in-modern-web-applications/" target="_blank" rel="noopener">«Links vs. Buttons in Modern Web Applications»</a>.</p><!-- SUB SECTION --><h3>Важливо структурувати розмітку за допомогою заголовків</h3><p>При створенні правильної схеми голосового озвучення використання <code>h1 — h6</code> допомагає користувачам краще зрозуміти структуру вашої сторінки і взаємозв'язок між окремими секціями. Крім того, це допоможе користувачам з допоміжними технологіями пересуватися по вашій сторінці.</p><p>Екранні читалки передбачають різні способи пересування від однієї одиниці контенту до іншої. Наприклад, при використанні скрінрідера користувач може пересуватися по заголовкам за допомогою гарячих клавіш.</p><div class="video"><iframe width="560" height="315" src="https://www.youtube.com/embed/QP1rzxMRap4?rel=0" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe></div><p>Коли ви вставляєте заголовки, вам слід уникати пропусків рівнів. Також не варто використовувати декілька елементів <code>h1</code>.</p><script type="text/plain" class="language-markup"><!-- Не пропускайте рівні: -->

        <body>
          <h1>Мій сайт</h1>
          <h4>Заголовок</h4>
          <h2>Підзаголовок</h2>
          <h3>Заголовок</h3>
        </body>
        <!-- Не покладайтеся на неіснуючі алгоритми: -->

        <body>
          <h1>Мій сайт</h1>
          <section>
            <h1>Заголовок</h1>
            <section>
              <h1>Підзаголовок</h1>
            </section>
          </section>
          <section>
            <h1>Заголовок</h1>
          </section>
        </body>
        <!-- Робіть так: -->

        <body>
          <h1>Мій сайт</h1>
          <h2>Заголовок</h2>
          <h3>Підзаголовок</h3>
          <h2>Заголовок</h2>
        </body></script><p><a href="http://khan.github.io/tota11y/" target="_blank" rel="noopener">tota11y</a> надає хороший спосіб перевірки стійкості вашої схеми. Інший спосіб - відключити CSS і перевірити, читається чи сторінка і чи має структура сенс.</p><!-- SUB SECTION --><h3>Використання орієнтирів допомагає людям пересуватися по вашому сайту</h3><p>Можна і навіть потрібно розмічати тематичні секції за допомогою HTML5 тегів ( <code>article</code>, <code>aside</code>, <code>nav</code>, <code>section</code> і т.д.). Також можна використовувати ARIA-атрибут <code>role</code> для старіших браузерів або секцій, які не мають для позначення специфічних тегів, наприклад, пошуку. Секційні елементи не є прямою заміною елементу <code>div</code>. Використовуйте їх для розмітки великих шматків пов'язаного контенту, що відрізняється від решти контенту на сторінці. Не зловживайте секційними елементами. Використовуйте <code>div</code> для CSS / JS, а секції для семантики.</p><p>Одним з переваг такого підходу є можливість користувачам скрінрідеров переміщатися по сторінці, перестрибуючи з секції на секцію. Такі секції для навігації називаються орієнтирами (landmarks). Подивіться <a href="https://youtu.be/IhWMou12_Vk" target="_blank" rel="noopener">відео</a> на YouTube.</p><script type="text/plain" class="language-markup"><body>
  <header> <!-- орієнтир -->
    <nav> <!-- орієнтир -->
      ...
    </nav>
  </header>
  <aside> <!-- орієнтир -->
  </aside>
</body></script><!-- SUB SECTION --><h4>main, header і footer також є орієнтирами</h4><p>Обертаючи основний контент сайту в елемент <code>main</code>, ви дозволяєте користувачам переміститися до нього за допомогою гарячих клавіш. «Елемент <code>main</code> вказує на секцію з основним контентом в документі або додатку» і не повинен використовуватися більше одного разу.</p><p>Як вже говорилося, правильно розділяти контент на орієнтири. <code>header</code> і <code>footer</code> сприймаються усіма основними браузерами як орієнтири, якщо вони не знаходяться всередині елементів <code>section</code> або <code>article</code>. Якщо вам потрібна підтримка старіших браузерів, то ви можете перетворити шапку і підвал вашого сайту в орієнтири за допомогою атрибута <code>role</code>.</p><script type="text/plain" class="language-markup"><!-- Додаткові атрибути `role` важливі тільки для старих браузерів -->

        <body>
          <header role="banner">
            <h1>Мій персональний блог</h1>
          </header>
          <main>
            <section>
              <h2>Пости в блозі</h2>
              ....
            </section>
          </main>
          <footer role="contentinfo">
            &copy; 2017 Я
          </footer>
        </body></script></section><!-- SECTION --><section><h2 id="a11y-css">Пишемо CSS, не забуваючи про доступність</h2><p>CSS пройшов довгий шлях розвитку від фіксованої ширини до чуйного веб-дизайну, від сітки на таблицях до грід, і нам більше не потрібно використовувати картинки для бордерів, шрифтів або тіней. У нас є кастомні властивості, <code>@supports</code>, <code>calc()</code> і сотні інших нових можливостей. Безумовно, це всього лише одна з гілок неймовірних досягнень в сфері розробки останніх років.</p><p>У той час, як великий набір властивостей і нескінченну кількість способів вирішення однієї задачі за допомогою CSS роблять життя простіше, це також потенційно здатне погіршити досвід взаємодії користувача з інтерфейсом.</p><p>У цій секції зібрані методи і підходи, які допоможуть вам писати більш доступний CSS.</p><!-- SUB SECTION --><h3>Від розбірливого до читабельного тексту</h3><p>Картинки, іконки і відео є невід'ємною частиною сучасного веб-сайту, але текст як і раніше становить основну частину контенту на більшості сторінок. Важливо приділити пильну увагу стилізації, тестування і ретельному підбору властивостей шрифту, оскільки текст повинен бути читабельним незалежно від пристрою.</p><figure><img src="../images/module-11/a11y-font-size.jpeg" alt="изменяя размер шрифта"><figcaption>Розмір шрифту повинен збільшуватися пропорційно дистанції між користувачем і екраном</figcaption></figure><p>Були часи, коли розмір шрифту в 12px для основного тексту був нормою, але зі зростанням кількості девайсів з високою роздільною здатністю розмір шрифту на якийсь час устаканиться в районі 15-18px. За останні роки він підріс до 20px і більш, що цілком непогано. Текст повинен бути досить великим для читання зі смартфона. І повинен зростати з розмірами екрану для того, щоб читатися з великої дистанції на великих екранах, таких, як телевізор.</p><p>Оскільки характеристики шрифтів можуть сильно відрізнятися, немає сенсу домовлятися про якийсь стандартному мінімальному розмірі, але 18-20px чудово підійдуть в якості відправної точки для маленьких екранів.</p><p>За більшою кількістю деталей я раджу звернутися до статті <a href="https://blog.marvelapp.com/body-text-small/" target="_blank" rel="noopener">Your Body Text Is Too Small</a>.</p><!-- SUB SECTION --><h3>Налаштування інтерліньяжу</h3><p>Висота рядка за замовчуванням в браузерах становить приблизно 1.2. Згідно з рекомендацією <code>1.2</code>. Согласно рекомендации <a href="https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-visual-presentation" target="_blank" rel="noopener">Керівництва по доступності веб-контенту</a>, <code>line-height</code> повинен бути не менше <code>1.5</code> в абзацах всередині блоків тексту.</p><figure><img src="../images/module-11/a11y-line-height.png" alt="изменяя размер шрифта"><figcaption>Абзац з line-height: 1.2 в порівнянні з абзацом з line-height: 1.5</figcaption></figure><p>Текст в абзаці з правильно підібраною висотою рядка не тільки краще читається, але і виглядає акуратніше.</p><!-- SUB SECTION --><h3>Вирівнювання тексту</h3><p>Незважаючи на те, що деякі з нас вважають за краще розподілений текст вирівняні по правому або лівому краю (мовляв, він виглядає приємніше), це вважається поганою практикою. <code>text-align: justify</code> змінює відстань між словами для створення рядків однакової довжини. Ці нерівномірні відступи можуть погіршити читабельність тексту і просто відволікати. Перенесення слів в разі потреби може бути непоганим рішенням, але перенесення в CSS погано підтримується і може працювати не так, як очікувалося.</p><figure><img src="../images/module-11/a11y-text-align.png" alt="изменяя размер шрифта"><figcaption>Неравномерные отступы между словами при text-align: justify</figcaption></figure><!-- SUB SECTION --><h3>Обмеження ширини абзацу</h3><p>Згідно з декількома джерелами, дизайнери повинні прагнути до <a href="https://www.smashingmagazine.com/2014/09/balancing-line-length-font-size-responsive-web-design/" target="_blank" rel="noopener">ширини рядка в 45-85 символів</a>, оскільки передбачувана комфортна ширина дорівнює 65 символам.</p><p>Якщо ви використовуєте чуйну типографіку, то не забудьте протестувати свій сайт на великих екранах. Якщо не встановлена ​​верхня межа розміру шрифту, то ваш текст може стати нечитабельним при певному розмірі вьюпорта. Для ознайомлення з технікою завдання кордонів і чуйною типографікою, почитайте статтю <a href="https://madebymike.com.au/writing/precise-control-responsive-typography/" target="_blank" rel="noopener">Precise control over responsive typography</a>.</p><!-- SUB SECTION --><h3>content у псевдоелементі</h3><p>Ми можемо використовувати псевдоелементи <code>::before</code> і <code>::after</code>, щоб додати CSS в самому початку або в самому кінці елемента. Це дозволяє нам просто і зручно додавати оформлювальні елементи, але також це дозволяє додавати контент за допомогою властивості <code>content</code>. З точки зору принципу поділу відповідальності ми не повинні цього робити.</p><pre class="language-css"><code>h2 {
  content: "НЕ ТРЕБА ТАК";
}</code></pre><p>Контент повинен бути в HTML, в базі даних або приходити через API, але не в CSS. Іноді ми використовуємо властивість <code>content</code> для додавання не текстового контенту, такого, як іконічні шрифти або спецсимволи. Якщо ви так робите, то пам'ятайте, що деякі <a href="https://tink.uk/accessibility-support-for-css-generated-content/" target="_blank" rel="noopener">програми читання з екрану</a> розпізнають і промовляють згенерований контент. Якщо створений контент є чисто оформлювальних, то переконаєтеся, що він прихований від усіляких асистентів. Наприклад, використовуючи <code>aria-hidden</code>.</p><script type="text/plain" class="language-markup"><span class="icon icon-key" aria-hidden="true"></span></script><!-- SUB SECTION --><h3>Екран - не єдина середовище взаємодії</h3><p>Незважаючи на те, що ми живемо в 21-му столітті, люди як і раніше багато роздруковують. Переконайтеся, що ваші сторінки доступні для використання навіть після роздруківки або збереження в PDF. Все, що вам потрібно зробити - додати блок <code>@media</code> в свій CSS і налаштувати стилі елементів, які виглядають погано. Або взагалі сховайте елементи, що не мають сенсу на папері: навігацію, рекламу і т.д.</p><pre class="language-css"><code>@media print {
  .header {
    position: static;
  }
  nav {
    display: none;
  }
}</code></pre><p>Одна з ситуацій з роздрукованими сторінками - досконала марність посилань. На паперовому носії ви не знаєте, куди вони повинні вести. На щастя, CSS дає нам можливість <a href="https://alistapart.com/article/goingtoprint" target="_blank" rel="noopener">виводити значення атрибутів на екран</a> (на папір в нашому випадку).</p><pre class="language-css"><code>@media print {
  a[href^="http"]:not([href*="mywebsite.com"])::after {
    content: " (" attr(href) ")";
  }
}</code></pre><p>За допомогою цих рядків коду при друку після кожного посилання, значення атрибута <code>href</code> у яких містить <code>http</code>, і при цьому не містить <code>mywebsite.com</code> в адресі, в дужках будуть відображатися <code>url</code>.</p><p>Firefox і Chrome пропонують <a href="https://uxdesign.cc/i-totally-forgot-about-print-style-sheets-f1e6604cfd6#63e3" target="_blank" rel="noopener">інструменти для тестування і налагодження стилів сторінки при друку.</a>. Якщо ви хочете копнути глибше, рекомендується ознайомитися з усією статтею.</p><!-- SUB SECTION --><h3>Фолбек для значень з частковою підтримкою</h3><p>Іноді ми опиняємося в ситуації, коли хочемо використовувати певне значення властивості, але не можемо, оскільки воно підтримується не у всіх браузерах. Але до тих пір, поки ми забезпечуємо фолбек, ми не повинні обмежувати себе у використанні таких властивостей. Часто нам навіть не потрібні директиви <code>@supports</code> або інші способи визначення. Припустимо, ви хочете використовувати значення в <code>vmax</code>, але IE і старі версії Edge його не розуміють.</p><pre class="language-css"><code>div {
  width: 50vmax; /* Не спрацює в IE і старих версіях Edge */
}</code></pre><p>Щоб забезпечити фолбек, ви просто встановлюєте значення властивості <code>width</code> в менш придатних, але зрозумілих цим браузерам одиницях. Наприклад, <code>width: 50vw</code>. Нижче, в наступному рядку, ви задаєте те значення, яке хочете.</p><pre class="language-css"><code>div {
  width: 50vw;
  width: 50vmax;
}</code></pre><p>Браузери, які не розуміють <code>vmax</code>, будуть виконувати рядок <code>width: 50vw</code> і просто пропустять <code>width: 50vmax</code>. З іншого боку, браузери, які підтримують ці одиниці, спочатку виконають <code>width: 50vw</code>, а потім <code>width: 50vmax</code>. Оскільки оголошення <code>vmax</code> знаходиться після оголошення <code>vw</code>, версія <code>vmax</code>  —  це те, що побачить користувач.</p><!-- SUB SECTION --><h3>Існує багато способів заховати контент</h3><p>Заголовки в HTML дуже корисні, коли справа доходить до складання структури документа. Використовуючи заголовки <code>h1 - h6</code>, ви повідомляєте браузеру і іншому софту, як структурований ваш документ і як пов'язані його частини. Дуже важливо мати чітку схему документа, це добре для SEO, і це допомагає користувачам програм читання з екрану переміщатися по вашому сайту.</p><p>Може трапитися так, що вам потрібно впровадити дизайн, в якому немає заголовків, незважаючи на те, що було б розумно їх мати. Це трапляється, коли сам дизайн передає структуру. В такому разі не видаляйте заголовки з розмітки, просто сховайте їх. Повинно бути ясно, як ваш документ влаштований з CSS або без нього.</p><p>Це, звичайно, всього лише один приклад. Інший приклад - візуальне приховання лейблів в формах (навіть з точки зору UX ви <a href="https://www.nngroup.com/articles/form-design-placeholders/" target="_blank" rel="noopener">не повинні приховувати лейбли</a>). В CSS є кілька способів приховування контенту, і вам вирішувати, який із методів приховування вибрати в конкретній ситуації.</p><!-- SUB SECTION --><h4>Ховайте контент від усіх</h4><p>За допомогою атрибута <code>hidden</code>, або правила <code>visibility: hidden</code>, або <code>display: none</code> ви ховаєте контент повністю. Його користувачі не можуть його побачити, а програми читання з екрану - прочитати.</p><!-- SUB SECTION --><h4>Ховайте контент візуально</h4><p>Приховати контент тільки візуально не так-то просто. Вам потрібно переконатися, що він все ще доступний для програм читання, вам доводиться мати справу з примхами браузера, і вам потрібно вирішити, що відбувається, коли елемент у фокусі. Звичайно, вже придумали рішення для цього завдання, якими ви можете використовувати.</p><p>Існує багато різних підходів. Нижче наведено рекомендований метод розкладений по поличках, щоб повністю зрозуміти, що відбувається.</p><pre class="language-css"><code>.visually-hidden {
  /* Видаляємо елемент з потоку документа */
  position: absolute;
  /* Тимчасове рішення для невірно сказаного, розмазав тексту */
  white-space: nowrap;
  /* Встановлюємо мінімально можливий розмір (деякі скрінрідери ігнорують елементи з нульовою висотою і шириною) */
  width: 1px;
  height: 1px;
  /* Приховуємо контент який вилазить за межі */
  overflow: hidden;
  /* Скидаємо будь-які властивості, які можуть вплинути на розмір елемента */
  border: 0;
  padding: 0;
  /* Вирізаємо ту частину контенту, яка повинна відображатися. */
  /* Застаріла властивість clip для старих браузерів */
  clip: rect(0 0 0 0);
  /* clip-path для нових браузерів. inset (50%) визначає область вставки, яка дозволить контенту зникнути.  */
  clip-path: inset(50%);
    /* Схоже, ніхто до кінця не розуміє, чому тут margin: -1px. Крім того, це призводить до проблем (читай: https://github.com/h5bp/html5-boilerplate/issues/1985). */
  margin: -1px;
}</code></pre><p>Збережіть цей клас десь і використовуйте щоразу, коли захочете приховувати контент візуально, але залишити його доступним для допоміжних технологій і пошукових систем.</p><!-- SUB SECTION --><h4>Ховайте контент семантично</h4><p>Іноді має сенс відображати контент візуально, але приховувати його від програм читання з екрану, наприклад, у випадках з іконками. В цьому випадку додайте атрибут <code>aria-hidden</code> до елементу, який ви хочете приховати, і встановіть йому значення <code>true</code>.</p><script type="text/plain" class="language-markup"><button>
  <span class="icon icon-hamburger" aria-hidden="true"></span>
  <span class="text">Menu</span>
</button></script><!-- SUB SECTION --><h4>Інші способи</h4><p>Існують і інші способи приховування контенту: негативний <code>text-indent</code> або нульовий <code>font-size</code> або <code>height</code>. Хоча деякі з них цілком робочі, варто використовувати їх з обережністю. Прочитайте статтю <a href="https://webaim.org/techniques/css/invisiblecontent/#techniques" target="_blank" rel="noopener">Techniques for hiding text</a>.</p><!-- SUB SECTION --><h3>Не довіряйте поганому контрасту</h3><p>Створюваний нами дизайн повинен забезпечувати достатній контраст між текстом і фоном, щоб бути досить розбірливим. Висока контрастність хороша як для людей з обмеженнями зору, так і без них. Просто уявіть, що користуєтеся своїм смартфоном на вулиці в сонячний день.</p><!-- SUB SECTION --><h4>Що таке колірний контраст і чому це важливо</h4><p>За даними Всесвітньої організації охорони здоров'я, близько 4% населення мають обмеження зренія.Многіе з цих порушень зменшують чутливість до контрасту, а в деяких випадках позбавляють здатності розрізняти кольори.</p><p>Два кольори контрастують, коли вони з різних сегментів колірного кола. Простіше кажучи, чим більше різниця між двома кольорами, тим вище контраст. Для нас, веб-дизайнерів і розробників, мова йде не тільки про контрасті, а й про те, як добре він працює стосовно тексту. Контраст між текстом і його фоном повинен бути настільки високим, щоб його могли читати люди з досить низьким зором. Звичайно, не потрібно гадати, чи відповідає наш інтерфейс цим критерієм. <a href="https://www.w3.org/WAI/" target="_blank" rel="noopener">Ініціатива доступності веб-сторінок (WAI)</a> визначила співвідношення для вимірювання контрасту.</p><!-- SUB SECTION --><h4>Мінімальний коефіцієнт контрастності</h4><p>Коефіцієнт контрастності показує, наскільки висока контрастність тексту в певних розмірах і завширшки на певному тлі. Співвідношення може варіюватися від <code>1:1</code> до <code>21:1</code>. Де <code>1:1</code> якщо обидва кольори збігаються, а <code>21:1</code>, якщо використовуються чорні і білі кольори.</p><figure><img src="../images/module-11/a11y-contrast.png" alt=""><figcaption>Коефіцієнт дорівнює 3.3 для кольору тексту # 777777 на тлі кольору #DDDDDD ( <a href="http://leaverou.github.io/contrast-ratio/" target="_blank" rel="noopener">Джерело</a>)</figcaption></figure><p>Згідно Керівництву по доступності контенту в інтернеті, ми повинні дотримуватися коефіцієнт контрастності не нижче <code>4.5:1</code> між фоном і текстом (або картинкою і текстом). Це може бути застосовано до тексту, якщо його розмір менше 24px (якщо не жирний) і менше 19px (якщо жирний). Для тексту більшого розміру досить коефіцієнта <code>3:1</code>.</p><p>Це складніше, ніж можна припустити. Проблема полягає не в тому, що не вистачає візуально приємних комбінацій, а в тому, що в останні роки дизайнер звик використовувати з низькою контрастністю пари. Все, від маленьких агентств до величезних компаній, типу Apple і Google, винні в поширенні цього негативного патерну.</p><!-- SUB SECTION --><h4>Вимірювання коефіцієнта контрастності</h4><p>У Chrome Canary можна відображати коефіцієнт контрастності безпосередньо в Інструментах розробника.</p><figure><img src="../images/module-11/a11y-dev-tools.png" alt=""><figcaption>Коефіцієнт контрастності в Dev Tools браузера Chrome.</figcaption></figure><p>Існує безліч інструментів для перевірки кольорового контрасту і доступності в цілому. Список нижче не є повним, але містить ті інструменти, які можна використовувати.</p><p><strong>Онлайн</strong></p><ul><li><a href="http://leaverou.github.io/contrast-ratio/" target="_blank" rel="noopener">Спритний і простий плагін для браузера</a></li><li><a href="https://snook.ca/technical/colour_contrast/colour.html#fg=33FF33,bg=333333" target="_blank" rel="noopener">Перевірка контрасту в браузері і пара додаткових опцій</a></li><li><a href="http://wave.webaim.org/" target="_blank" rel="noopener">Інструмент для перевірки контрасту і не тільки</a></li><li><a href="http://kevingutowski.github.io/color.html" target="_blank" rel="noopener">Піпетка з автоматичним визначенням контрасту</a></li></ul><p><strong>Розширення і інструменти розробника</strong></p><ul><li><a href="https://www.youtube.com/watch?v=b0Q5Zp_yKaU&list=PLNYkxOF6rcICWx0C9LVWWVqvHlYJyqw7g" target="_blank" rel="noopener">Панель аудиту в інструментах розробника в Chrome.</a></li><li><a href="http://khan.github.io/tota11y/" target="_blank" rel="noopener">tota11y - розширення для визначення контрасту, структури документа і багато чого іншого.</a></li><li><a href="https://chrome.google.com/webstore/detail/axe/lhdoppojpmngadmnindnejefpokejbdd" target="_blank" rel="noopener">aXe - автоматизований інструмент пошуку дефектів доступності на вашому сайті</a></li></ul><!-- SUB SECTION --><h3>Колір не повинен бути єдиним джерелом інформації</h3><p>Як уже згадувалося, люди мають недоліки колірного зору. Існують різні типи цього розладу. Дейтанопія (різновид дальтонізму) є одним з найпоширеніших і ускладнює диференціацію між червоним і зеленим. Ми повинні уникати використання кольорів як візуальних сигналів, оскільки інтерфейси можуть стати непридатними для людей з розладом такого типу.</p><p>Те що користувач з нормальним зором бачить як зелену рамку поля форми, що сигналізує що все ок, користувачів з дейтанопією побачить як червону і подумає що у нього помилка введення.</p><p>Додавання простеньких іконок може допомогти поліпшити доступність призначеного для користувача інтерфейсу. Іншим прикладом є посилання. Вони теж не повинні відрізнятися від звичайного тексту тільки кольором. Найкраще залишати у посилань підкреслення.</p><!-- SUB SECTION --><h3>Подбайте про порядок</h3><p>Існує безліч способів зміни порядку елементів. Наприклад, є <code>order</code> і <code>flex-direction</code> для флексбоксов або <code>order</code>, <code>flex-auto-flow</code> і, звичайно, явне вказівку порядку для грід. Хоча ці властивості дійсно корисні, вони можуть <a href="https://tink.uk/flexbox-the-keyboard-navigation-disconnect/" target="_blank" rel="noopener">розірвати зв'язок між порядком в DOM і візуальним представленням контенту </a>.</p><p>Змінений, непередбачуваний порядок не сподобається не тільки користувачам з клавіатурою (без мишки). Екранні читалки читають контент в порядку його проходження в DOM. Софту все одно який порядок в CSS, а ось користувачам немає. Ви могли б подумати, що користувачі екранних читалок не піклуються про візуальному поданні контенту. Це не завжди так, тому що не всі користувачі скрінрідерів сліпі. Деякі з них мають поганий зір або недоліки в навчанні (наприклад, не вміють читати) і використовують програми читання з екрану для доповнення того, що вони бачать на екрані.</p><p>Питання порядку актуальний не тільки для флексбоксов або гридів, а й взагалі для всіх видів позиціонування. Важливо розташовувати контент в тому порядку, в якому він має сенс навіть без стилів, а вже потім думати про відповідність дизайну. Якщо так не виходить, то вам варто переглянути дизайн. У будь-якому випадку вам не слід сліпо міняти порядок елементів в розмітці тільки тому що ви не можете їх спозиціонувати за допомогою CSS.</p><p>Подивіться <a href="https://youtu.be/8MAvH6vYbDo" target="_blank" rel="noopener">Does reordering content affect accessibility?</a> і прочитайте статтю <a href="http://adrianroselli.com/2015/09/source-order-matters.html" target="_blank" rel="noopener">Source Order Matters</a> для більш докладної інформації.</p><!-- SUB SECTION --><h3>Фокусуємось на важливому: focus</h3><p>Вкрай важливо переконатися в тому, що навігація по вашому сайту можлива за допомогою клавіатури. Дуже багато людей використовують клавіатуру при серфінгу. Серед них користувачі з обмеженнями моторно-рухових функцій, сліпі люди - все ті, хто з якихось причин не може користуватися мишкою та трекпедом. Є пара речей, які ви можете зробити в CSS, щоб стилізувати елементи, що знаходяться в фокусі.</p><!-- SUB SECTION --><h4>Виділяємо елементи в фокусі</h4><p>Ви можете виділити елементи <a href="https://allyjs.io/data-tables/focusable.html" target="_blank" rel="noopener">в фокусі </a>за допомогою стилів для псевдокласу <code>:focus</code>.</p><pre class="language-css"><code>a:focus {
  background-color: #000000;
  color: #FFFFFF;
}</code></pre><p>У браузерів немає єдиної точки зору на стилі для елементів у фокусі. Такі стилі часто потворні і <a href="http://adrianroselli.com/2017/02/avoid-default-browser-focus-styles.html" target="_blank" rel="noopener">не дуже добре поєднуються з вашим дизайном</a>. Рекомендується передбачити індивідуальні стилі фокусування, які покращують користувальницький інтерфейс і відповідають вашому дизайну.</p><p>Що б ви не робили, <a href="http://www.outlinenone.com/" target="_blank" rel="noopener">ніколи просто не видаляйте обведення, що відображається за замовчуванням </a>(пунктирна лінія, синє або помаранчеве кільце), котрі дають альтернативні стилі. Користувачі, які використовують клавіатуру в якості основного способу навігації, не зможуть використовувати ваш сайт, якщо не знатимуть, де знаходиться фокус в даний момент.</p><p>Не знімайте стилі фокуса за замовчуванням, не надаючи альтернативу. Це не просто побажання. Ця вимога <a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/navigation-mechanisms-focus-visible.html" target="_blank" rel="noopener">рівня AA</a>.</p><!-- SUB SECTION --><h4>Стилі елемента при фокусі на дочірніх елементах</h4><p><code>:focus-within</code> — відносно новий псевдоклас і вже підтримується в більшості основних браузерів. Він вибирає елемент з дочірніми елементами, які в даний час в фокусі.</p><figure><img src="../images/module-11/a11y-focus-within.gif" alt=""><figcaption>Форма, которой добавляется тень, если один из дочерних элементов в фокусе</figcaption></figure><pre class="language-css"><code>form:focus-within {
  box-shadow: 0 0 4px 6px rgba(80,88,156,0.2);
}</code></pre><p>Для поглиблення в тему основ фокуса подивіться відео <a href="https://youtu.be/EFv9ubbZLKw?list=PLNYkxOF6rcICWx0C9LVWWVqvHlYJyqw7g" target="_blank" rel="noopener">What is Focus?</a>.</p><!-- SUB SECTION --><h3>Висновок</h3><p>Незважаючи на те, що ця секція охоплює чимало різних ситуацій, написане тут далеко не все, що вам потрібно знати про доступність в CSS. Краще сприймати це як відправну точку. Формуючи DOM правильно і піклуючись про порядок, думаючи про високої контрастності, створюючи свої інтерфейси з думками про доступність, ви вже робите величезну роботу. Якщо ви приділите трохи більше уваги кожній новій сторінці або сайту, який ви робите, то ви внесете вклад в покращення інтернету.</p><h3>Додаткові матеріали</h3><ul><li><a href="https://github.com/brunopulis/awesome-a11y" target="_blank" rel="noopener">Ресурс по a11y</a></li><li><a href="http://htmldog.com/guides/html/advanced/forms/" target="_blank" rel="noopener">Доступні форми</a></li></ul></section><!-- ========================  Schema.org  =========================== --><section><h2 id="microdata">Microdata</h2><p>Веб-сторінки були задумані і створені для обміну інформацією між людьми. Зростання числа веб-сторінок, поява нових сервісів подібних інтернет-магазинах, соціальним мережам і т.п. створив попит на обмін інформацією між програмами. Наприклад, при пошуку за ключовими словами потрібно не просто знайти фрази, що збігаються із запитом, а й якимось чином проаналізувати текст і запропонувати користувачеві найбільш прийнятних відповідей в зручному для сприйняття людини вигляді. Це неможливо без мови, що пояснює машинам вміст контенту в тегах HTML.</p><p>HTML5 дозволяє використовувати атрибути тега для запису, зберігання та читання додаткової інформації. Google, Bing, Yahoo і інші компанії в 2011 році прийняли стандарт зрозумілий для пошукових роботів. Провідні світові компанії фактично поставили стандарт, відомий як <strong><a href="http://schema.org/docs/documents.html" target="_blank">schema.org</a> </strong>описує теми, структуру і іменування атрибутів, необхідних для пошукових сервісів. З тих пір успіх в просуванні сайту багато в чому заснований на оформленні веб-сторінки на основі цього стандарту.</p><p data-height="400" data-theme-id="30735" data-slug-hash="mMwbmw" data-default-tab="html,result" data-user="GoIT-fe" data-embed-version="2" data-pen-title="schema" class="codepen">See the Pen <a href="https://codepen.io/GoIT-fe/pen/mMwbmw/">schema</a> by GoIT ( <a href="https://codepen.io/GoIT-fe">@GoIT-fe</a>) on <a href="https://codepen.io">CodePen</a>.</p><p>Ідея стандарту schema.org задоволена проста. Наприклад, якщо в тезі <code>span</code> міститься текст <strong>Kit Harington</strong>, то пошуковий робот може звернутися до атрибуту цього тега і прочитати в ньому <code>itemprop="name"</code>. Потім робот може піднятися до безпосереднього предка і прочитати в атрибуті <code>itemprop="actor" itemscope itemtype="http://schema.org/Person"</code>, а якщо піднятися ще вище, то і <code>itemtype="http://schema.org/TVSeries"</code>.</p><p>В результаті один тег з ім'ям і оформлення цього тега згідно правил <strong>schema.org</strong> дозволяють створити таку таблицю, де <code>itemscope</code> задає область видимості об'єкта <code>itemtype</code>, а <code>itemprop</code> визначає властивості об'єкта.</p><table><tr><th>Назва атрибута</th><th>Значення атрибута</th><th>Текст тега</th></tr><tr><td>itemprop</td><td>name</td><td>Kit Harington</td></tr><tr><td>itemprop</td><td>actor</td><td>Kit Harington</td></tr><tr><td>itemscope itemtype</td><td>http://schema.org/Person</td><td>Kit Harington</td></tr><tr><td>itemtype</td><td>http://schema.org/TVSeries</td><td>Kit Harington</td></tr></table><p>Отримана таким чином інформація може бути оброблена і запропонована користувачеві в структурованому вигляді. Якщо ви наберете в рядку пошуку google текст <strong>game of thrones tv show</strong>, то ви побачите, як на додаток до звичайних результатів пошуку праворуч з'являється блок інформації з скріншот цього серіалу, короткою анотацією, посиланнями на авторів, акторів і т.п.</p><p>Це фактично готовий блок (section) веб-сторінки, створений на основі аналізу атрибутів і розміщенні контенту тегів в спеціальний шаблон. Цей приклад дозволяє користувачеві побачити приховані можливості мікророзмітки. Причому під словом "приховані" мається на увазі головна особливість цього типу даних, а саме - зручність для читання програмами, а не людьми.</p><div><img src="../images/module-11/schema.png" alt="game of thrones tv show image"></div><p>Існують сервіси, що дозволяють провести валідацію коду за стандартом schema.org - <a href="https://search.google.com/structured-data/testing-tool" target="_blank">Structured Data Testing Tool</a>. Сайт <strong>schema.org</strong> добре документований, в ньому вказана <a href="http://schema.org/docs/full.html" target="_blank">структура всіх тем</a> і для кожної з тим наводиться докладний <a href="http://schema.org/TVSeries" target="_blank">опис і приклади</a> в форматі Microdata, а також в альтернативному синтаксисі стандартів RDFa і JSON-LD.</p><p>Крім мікророзмітки schema.org існують і інші стандарти. Найбільш популярні <strong>Open Graph</strong> від Facebook і <strong>мікроформат</strong> - ціле сімейство словників спеціалізуються на:</p><ul><li><code>hCard</code> - організації і люди</li><li><code>hCalendar</code> - події</li><li><code>geo</code> - географічні координати</li><li><code>hProduct</code> - товари</li></ul><p>Це не повний перелік мікроформатів, тому що цей стандарт постійно розробляється і доповнюється.</p><h2>Додаткові матеріали</h2><ul><li><a href="http://i-marketinga.net/semanticheskaya-razmetka-shema-org-dlya-seo/" target="_blank">Семантична розмітка Shema.org для SEO</a></li><li><a href="https://web-ux.ru/seo/novovvedeniya-semanticheskoi-mikrorazmetki" target="_blank">Основні типи мікророзмітки</a></li><li><a href="https://habrahabr.ru/post/141216/" target="_blank">Microdata DOM API</a></li></ul></section></article><!-- ============================== #page-navigator =============================================  --> <a href="#main-nav" class="to-page-nav"></a><!-- ============================== #end page-navigator =============================================  --></div></body></html>