<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Модуль 10</title>
  <link rel="stylesheet" href="../css/styles.min.css">
  <script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
  <script async src="../scripts/prism.js"></script>
</head>

<body class="theory-page">
  <div class="wrapper">
    <article>
      <header>
        <h1>Модуль 10 - Теорія</h1>
        <!-- ===== page-navigator =====  -->
        <nav class="table-of-contents" id="main-nav">
          <ol class="page-nav">
            <li>
              <a href="#cross">Кросбраузерність</a>
            </li>
            <li>
              <a href="#gd-pe">Graceful Degradation і Progressive Enhancement</a>
            </li>
            <li>
              <a href="#retina">Екрани високої піксельної щільності</a>
            </li>
            <li>
              <a href="#retina-res">Підготовка ресурсів для Retina</a>
            </li>
            <li>
              <a href="#svg">Основи роботи з SVG</a>
            </li>
            <li>
              <a href="#bem">Методологія BEM</a>
            </li>
            <li>
              <a href="#resources">Додаткові матеріали</a>
            </li>
          </ol>
        </nav>
        <!-- ====== end page-navigator =====  -->
      </header>

      <!-- SECTION -->
      <section id="cross">
        <h2>Кросбраузерність</h2>
        <p>Зображення стилів тегів може відрізнятися у різних браузерах, оскільки вони створені різними компаніями та
          немає єдиного стандарту реалізації css у браузері. Тому з'явилася необхідність кросбраузерності, щоб образ
          веб-сайту, задуманий дизайнером, мав однаковий вигляд.</p>
        <p>
          <strong>Кросбраузерне верстання</strong> – верстання, націлене на створення сайту, що показується в кожному
          браузері однаково коректно.</p>
        <p>Є підходи та правила, яких варто дотримуватися при розробці. За умови їх використання, кількість відмінностей
          між зображенням сторінки в різних браузерах зводиться до мінімуму або зникає зовсім. Розгляньмо їх детальніше.
        </p>

        <!-- subsection -->
        <h3>Усталене значення властивостей</h3>
        <p>
          <strong>Властивості</strong> – це відступи, кольори, шрифти тощо. У кожному браузері вони можуть бути різними.
          Усе це повинно бути описано в таблиці стилів, інакше браузер самостійно проставлятиме усталені значення. Тому
          в кожному з них сайт зображатиметься по-різному. Частково розв'язати цю проблему допомагає використання: </p>
        <ul>
          <li>
            <a href="http://cssreset.com/scripts/eric-meyer-reset-css/" target="_blank">
              <strong>reset.css</strong>
            </a>
            - повне скидання стилів в 0. Не рекомендується використання "як є" на реальних проєктах. Можна вважати це
            базою, на якій базуватиметься скидання і налаштування для проєкту.
          </li>
          <li>
            <a href="https://necolas.github.io/normalize.css/" target="_blank">
              <strong>normalize.css</strong>
            </a> - це невеликий CSS файл, який забезпечує для HTML елементів кращу кросбраузерність в усталених стилях.
            Це сучасна, готова до HTML5 альтернатива традиційному reset.css
          </li>
          <li>CSS фреймворки, більшість вміщують свою версію normalize.css</li>
          <li>чи хоч би мінімальне скидання наступним css правилом: * {padding: 0; margin: 0; box-sizing: border-box;}
          </li>
        </ul>

        <!-- subsection -->
        <h3>Валідація коду</h3>
        <p>Код, що не пройшов валідацію, спричинює помилки зображення елементів сторінки. Завжди перевіряйте ваш HTML і
          CSS код валідаторами.</p>
        <ul>
          <li>
            <a href="https://validator.w3.org/" target="_blank">HTML валідатор</a>
          </li>
          <li>
            <a href="https://jigsaw.w3.org/css-validator/" target="_blank">CSS валідатор</a>
          </li>
        </ul>

        <!-- subsection -->
        <h3>Dry code</h3>
        <p>Пишіть dry (don't repeat yourself, сухий) код. Що це означає? Не використовуйте зайві css властивості, які
          нічого не роблять для вашого блоку. Стежте, щоб властивості не повторювалися і не перевизначали один одного в
          контексті одного css правила. Використайте мінімальну кількість коду для досягнення мети.
        </p>

        <!-- subsection -->
        <h3>Інструменти розробника</h3>
        <p>Навчіться використовувати плагіни, що дозволяють швидше знаходити помилки коду для кожного з браузерів.
        </p>
        <ul>
          <li>
            <a href="https://developer.chrome.com/devtools" target="_blank">Chrome</a>
          </li>
          <li>
            <a href="https://developer.mozilla.org/en-US/docs/Tools" target="_blank">Firefox</a>
          </li>
          <li>
            <a href="http://www.opera.com/dragonfly/" target="_blank">Opera</a>
          </li>
          <li>
            <a href="https://docs.microsoft.com/en-us/microsoft-edge/f12-devtools-guide" target="_blank">Edge</a>
          </li>
          <li>
            <a href="https://developer.apple.com/safari/tools/" target="_blank">Safari</a>
          </li>
        </ul>

        <!-- subsection -->
        <h3>Вендорні префікси </h3>
        <p>Вендорні префікси — це приставки, використовувані виробниками (вендорами) браузерів для експериментальних, ще
          не прийнятих в стандарт, CSS властивостей. Використайте інструменти для їх автоматичного додавання в код,
          приміром, на початку можна користуватися
          <a href="http://autoprefixer.github.io/" target="_blank">Автопрефіксером</a>.</p>
        <p>Список вендорних префіксів:</p>
        <ul>
          <li>-webkit- (Chrome, Safari, новые версии Opera)</li>
          <li>-moz- (Firefox)</li>
          <li>-o- (Старые версии Opera)</li>
          <li>-ms- (Internet Explorer)</li>
        </ul>

        <!-- subsection -->
        <h3>Висновок</h3>
        <p>Розуміння причин некоректного зображення сайту, навичка кросбраузерного верстання приходять з часом і в
          процесі довгої практики. Тільки методом проб і помилок розробник може розібратися, які заморочки різні
          браузери мають. З досвідом верстальник намагається впорядкувати код так, щоб він був всіляко адаптований під
          кожен з браузерів, а в процесі верстання залишалося тільки підправляти невеликі косяки.</p>
      </section>

      <!-- SECTION -->
      <section id="gd-pe">
        <h2>Graceful Degradation і Progressive Enhancement</h2>
        <p>У цій частині ми коротко розглянемо різницю між двома підходами до створення призначених для користувача
          інтерфейсів : Витончена (поступова) деградація і Прогресивне (поступове) поліпшення.</p>

        <!-- subsection -->
        <h3>У чому різниця?</h3>
        <p>
          <strong>Витончена деградація (Graceful Degradation)</strong> - практика створення вебсайту, при якій він
          забезпечує гідний рівень зручності користувачів в сучасних браузерах. Проте, він деградуватиме витончено для
          тих, хто використовує старі браузери. Система може бути не такою приємною або красивою, але базова
          функціональність працюватиме на старіших системах. Як бонус, йде надання альтернативної версії функціонала або
          інформування користувача про недоліки продукту для забезпечення можливості використання продукту.</p>
        <p>
          <strong>Прогресивне поліпшення (Progressive Enhancement)</strong> - це аналогічна концепція як при граціозній
          деградації, але навпаки. Розробка розпочинається з базового рівня корисної функціональності й призначеного для
          користувача інтерфейсу для більшості браузерів. Розширена функціональність буде додана, коли браузер її
          підтримує. </p>
        <img src="../images/module-10/theory/pe-and-gd.png" alt="">

        <!-- subsection -->
        <h3>Глибше в Progressive Enhancement</h3>
        <p>
          <strong>Прогресивне поліпшення</strong> - метод створення сайтів з міцною основою, щоб він був доступний для
          широкого кола ситуацій перегляду: від мобільних пристроїв і нетбуків до настільних комп'ютерів і скрінрідерів.
          Насамперед, це послідовне розширення HTML (представлення), CSS (оформлення) і JavaScript (функціонал).
        </p>
        <img src="../images/module-10/theory/pe-layers.png" alt="">
        <ul>
          <li>
            <strong>Представлення (markup)</strong> - розпочинайте з семантичного і добре структурованого HTML для
            гнучкості й функціональної сумісності
          </li>
          <li>
            <strong>Оформлення (styling)</strong> - поступово покращуйте зовнішній вигляд дизайну, додаючи підтримку
            браузерів з великими можливостями
          </li>
          <li>
            <strong>Функціонал (behaviour)</strong> - розширюйте сайт за допомогою багатих інтерактивних функцій у
            веббраузерах за допомогою JavaScript
          </li>
        </ul>

        <p class="accent">Плюси:</p>
        <ul>
          <li>
            <strong>Доступність</strong> - контент доступний усім відвідувачам.</li>
          <li>
            <strong>Переносимість</strong> - підтримка більшості браузерів і пристроїв.</li>
          <li>
            <strong>Модульність</strong> - наявність розв'язаних компонентів з явними межами спрощує і підвищує
            відмовостійкість складання сайту
          </li>
          <li>
            <strong>Продуктивність</strong> - легше реалізуються поліпшення з точки часу завантаження сторінки.
          </li>
        </ul>

        <p class="accent">Мінуси:</p>
        <ul>
          <li>
            <strong>Час</strong> - потрібно додатковий час при розробці</li>
          <li>
            <strong>Виконання</strong> - складніше реалізувати у великих багатофункціональних застосунках, вимагає
            більше знань і досвіду розробки.
          </li>
          <li>
            <strong>Залежність</strong> - вебзастосункам з багатим функціоналом потрібні сценарії на стороні клієнта.
          </li>
        </ul>

        <!-- subsection -->
        <h3>Приклад</h3>
        <p>Простим прикладом є використання 24-бітових альфа-прозорих PNG.</p>
        <p>При GD ці зображення можуть показуватися в сучасних браузерах без проблем. Старіші браузери можуть показувати
          зображення, але ефект прозорості не спрацює (при необхідності його можна змусити працювати). Старі браузери,
          які не підтримують PNG, зображуватимуть текст або порожній простір.</p>
        <p>При PE ми можемо вирішити, що наш застосунок повинен функціонувати в усіх графічних браузерах. Тоді спочатку
          можна усталено використати зображення GIF нижчої якості, але замінювати їх 24-розрядними PNG, коли браузер їх
          підтримує.</p>
      </section>

      <!-- SECTION -->
      <section id="retina">
        <h2>Екрани високої піксельної щільності</h2>
        <p>У цій секції ми поговоримо про різницю між звичайним екраном і ретиною, а так само про терміни й прийоми, які
          використовуються при розробці для екранів високої піксельної щільності. Екран з високою піксельною щільністю
          сьогодні ні для кого не новина. Він є в кожному смартфоні. У 2010 році компанія Apple представила iPhone з
          екраном Retina, який подвоїв кількість пікселів на дюйм. Унаслідок цього релізу графіка стала чіткішою, ніж ми
          коли-небудь бачили.</p>

        <!-- subsection -->
        <h3>Роздільна здатність</h3>
        <p>
          <strong>Роздільна здатність (resolution)</strong> - кількість фізичних пікселів на екрані пристрою, зазвичай
          наводиться невирішеним, що додатково говорить про співвідношення сторін.
        </p>
        <table>
          <tr>
            <th>Роздільна здатність екрану</th>
            <th>Пристрій</th>
          </tr>
          <tr>
            <td>320 × 480</td>
            <td>Перший iPhone</td>
          </tr>
          <tr>
            <td>1024 × 768</td>
            <td>Канонічний десктоп</td>
          </tr>
          <tr>
            <td>2880 × 1800</td>
            <td>MacBook з ретиною</td>
          </tr>
        </table>

        <!-- subsection -->
        <h3>Щільність пікселів</h3>
        <p>
          <strong>Щільність пікселів (pixel density)</strong> - означає кількість пікселів, яка поміщається в один
          лінійний дюйм. Вимірюється в ppi (pixels per inch), відноситься до
          дисплеїв, матриць, сканерів.
        </p>
        <img src="../images/module-10/theory/ppi-diff.png" alt="">

        <!-- subsection -->
        <h3>Пікселі</h3>
        <p>Є декілька термінів, значення яких необхідно розуміти:</p>
        <ul>
          <li>
            <strong>Фізичний піксель (physical pixel)</strong> - осередок на матриці, одиниця роздільної здатності
            дисплею пристрою
          </li>
          <li>
            <strong>Віртуальний піксель (device independent pixel, dip)</strong> - незалежний від пристрою піксель, може
            бути більший, менший або дорівнює фізичному
          </li>
          <li>
            <strong>Змінений піксель</strong> - з'являється тоді, коли браузер або користувач масштабують зображення на
            екрані
          </li>
        </ul>
        <img src="../images/module-10/theory/pixel-diff.png" alt="">

        <!-- subsection -->
        <h3>Піксельне співвідношення</h3>
        <p>
          <strong>Піксельне співвідношення (pixel ratio)</strong> - відношення фізичного пікселя до віртуального. Може
          мінятися залежно від браузера.</p>
        <p>Для кращого розуміння розглянемо приклади:</p>
        <ul>
          <li>
            <strong>Nexus One</strong>: роздільна здатність 480 фізичних пікселів і 320 віртуальних, у результаті
            співвідношення 1.5
          </li>
          <li>
            <strong>MacBook з ретиною</strong>: роздільна здатність 2880 фізичних пікселів і 1440 віртуальних, у
            результаті співвідношення 2.0
          </li>
        </ul>

        <!-- subsection -->
        <h3>Retina</h3>
        <p>
          <strong>Retina</strong> - маркетинговий термін Apple, що описує пристрої з високою роздільною здатністю і
          піксельним співвідношенням більше ніж 1. Тобто віртуальний піксель збільшується щодо фізичного. Усі пристрої
          Apple мають співвідношення 1 або 2. Інші планшети та смартфони мають співвідношення від 1,5 до 2,25.</p>
        <img src="../images/module-10/theory/retina-example.png" alt="">
      </section>

      <!-- SECTION -->
      <section id="retina-res">
        <h2>Підготовка ресурсів для Retina</h2>
        <p>Для екранів високої піксельної щільності (далі просто Retina), потрібні спеціально підготовлені ресурси.
          Текст показується скрізь однаково, оскільки його рендерить сам браузер, найбільше страждають зображення.
          Навчімося готувати зображення для Retina.
        </p>
        <p>Найпростіший спосіб підготувати графіку до Retina дисплею — це просто розділити навпіл фізичні розміри
          зображення. Наприклад, щоб показати фотографію 200x300 пікселів на екрані зі збільшеною щільністю пікселів,
          необхідно завантажити фото розміром 400x600 пікселів і зменшити його, використовуючи CSS.</p>
        <p>Наступний малюнок якнайкраще описує процес підготовки png, jpg й інших зображень для retina. Для кожного
          екрану ми експортуємо зображення x1, x2 і x3 розміру від оригіналу, зберігаємо їх з відповідними префіксами
          @x2 @x3, для x1 (оригіналу) префікс не потрібний. Після чого ми використовуємо html або css для вказівки
          зображення.</p>
        <img src="../images/module-10/theory/images-for-retina.png" alt="">

        <!-- subsection -->
        <h3>Контентні зображення</h3>
        <p>Ми вже знайомі з тегами picture і source. Для контентних зображень ми використовуємо вже знайому нам
          конструкцію srcset, де вказуємо пари url-картинки та дескриптор щільності пікселів (позитивне число з рухомою
          комою, за яким йде "x". Усталене значення, якщо відсутній, рівне 1x.)
        </p>
        <p>В прикладі ми вказуємо 1x і 2x картинок, які використовуватимуться браузером на різних екранах, для фолбека
          описуємо img.</p>
        <p data-height="311" data-theme-id="30735" data-slug-hash="oeeXyx" data-default-tab="html,result"
          data-user="GoIT-fe" data-embed-version="2" data-pen-title="core-module-10-retina-content-img" class="codepen">
          See the Pen
          <a href="https://codepen.io/GoIT-fe/pen/oeeXyx/">core-module-10-retina-content-img</a> by GoIT (
          <a href="https://codepen.io/GoIT-fe">@GoIT-fe</a>) on
          <a href="https://codepen.io">CodePen</a>.</p>

        <!-- subsection -->
        <h3>Фонові зображення</h3>
        <p>З фоновими зображеннями цей процес трохи відрізняється. Використовуючи медіаправила і resolution, ми можемо
          вказати браузеру, при якій піксельній щільності екрану яке зображення використати.
        </p>
        <p data-height="305" data-theme-id="30735" data-slug-hash="OjjVwz" data-default-tab="css,result"
          data-user="GoIT-fe" data-embed-version="2" data-pen-title="core-module-10-retina-bg-img" class="codepen">See
          the Pen
          <a href="https://codepen.io/GoIT-fe/pen/OjjVwz/">core-module-10-retina-bg-img</a> by GoIT (
          <a href="https://codepen.io/GoIT-fe">@GoIT-fe</a>) on
          <a href="https://codepen.io">CodePen</a>.
        </p>
        <div class="note">
          <p>
            <strong>Підсумуємо</strong> - щоб зображення були чіткими на retina екранах, необхідно експортувати
            зображення в n разів більше оригіналу. Після чого, використовуючи тег picture\img для контентних і
            медіаправила для фонових зображень, вказати браузеру, яке зображення на якому екрані ми хочемо зобразити.
          </p>
        </div>
      </section>

      <!-- SECTION -->
      <section id="svg">
        <h2>Основи роботи з SVG</h2>
        <p>
          <strong>SVG (Scalable Vector Graphics)</strong> - векторний формат графіки, і мова, заснована на XML, для
          опису векторних зображень. Усередині файл не бінарний, а звичайний XML, що описує об'єкти, їхні ефекти і
          поведінку. SVG призначений для маркування графіки, а не контенту. Використати SVG досить легко, але є нюанси,
          про які ми повинні поговорити.
        </p>

        <!-- subsection -->
        <h3>Переваги SVG</h3>
        <ul>
          <li>
            <strong>Масштабування</strong>: на відміну від растрової графіки, SVG не втрачає якості при масштабуванні,
            тому SVG зручно використовувати для розробки під retina. При зміні масштабу SVG фігури завжди
            перемальовуються, завдяки чому ви завжди бачитимете гладке і красиве зображення, без пікселізації.
          </li>
          <li>
            <strong>Продуктивність</strong>: браузеру не треба просити картинку у сервера, оскільки він сам її малює,
            отже, продуктивність підвищується
          </li>
          <li>
            <strong>Зручність</strong>: за допомогою CSS/JS можна змінювати параметри графіки на сайті, наприклад фон,
            прозорість або границі.
          </li>
          <li>
            <strong>Анімація і редагування</strong>: за допомогою javascript можна анімувати SVG, а також редагувати в
            текстовому або графічному редакторові
          </li>
          <li>
            <strong>Малий розмір</strong>: об’єкти SVG важать набагато менше растрових зображень.
          </li>
        </ul>

        <p>Є декілька способів використання SVG. Деякі з них мають переваги, які можуть бути корисні залежно від того,
          чого ви хотіли б досягти, і деякі з них краще уникати. Якщо ви хочете просто зобразити картинку без
          інтерактивності, ви можете посилатися на SVG в img або як фонове зображення в CSS так само, як і на будь-який
          інший формат зображення.</p>

        <!-- subsection -->
        <h3>Використовуємо SVG як img</h3>
        <p>Використання SVG як тег
          <strong>img</strong> нічим не відрізняється від використання png, jpg або gif, просто вказуємо url до
          картинки. Іноді може знадобиться атрибут висоти або ширини (чи обоє). Зверніть увагу, 3 теги img різних
          розмірів і 1 svg, жодної пікселізації, навіть якщо ви максимально наблизите браузер, оскільки svg малюється
          самим браузером, як текст.
        </p>
        <p>Для браузерів, які не підтримують SVG або у разі фолбеку, ви можете посилатися на PNG або JPG з атрибуту src
          і використати атрибут srcset для посилання на SVG. В цьому разі тільки браузери, що підтримують SVG,
          завантажуватимуть SVG - старі браузери замість цього завантажуватимуть PNG. Також можна використати SVG в
          елементі picture.</p>
        <p data-height="273" data-theme-id="30735" data-slug-hash="ayyvWB" data-default-tab="html,result"
          data-user="GoIT-fe" data-embed-version="2" data-pen-title="core-module-10-svg-as-img" class="codepen">See the
          Pen
          <a href="https://codepen.io/GoIT-fe/pen/ayyvWB/">core-module-10-svg-as-img</a> by GoIT (
          <a href="https://codepen.io/GoIT-fe">@GoIT-fe</a>) on
          <a href="https://codepen.io">CodePen</a>.
        </p>

        <!-- subsection -->
        <h3>Використання SVG як фон</h3>
        <p>SVG може використовуватися як фонове зображення в CSS, також як PNG, JPG або GIF. Крім того, ми можемо робити
          все, що можна робити з растровою графікою, наприклад, повторювати фон. У наведеному нижче прикладі старі
          браузери дотримуватимуться PNG, який вони розуміють, тоді як новіші браузери завантажуватимуть SVG.</p>
        <p data-height="310" data-theme-id="30735" data-slug-hash="ayyvqJ" data-default-tab="css,result"
          data-user="GoIT-fe" data-embed-version="2" data-pen-title="core-module-10-svg-as-bg" class="codepen">See the
          Pen
          <a href="https://codepen.io/GoIT-fe/pen/ayyvqJ/">core-module-10-svg-as-bg</a> by GoIT (
          <a href="https://codepen.io/GoIT-fe">@GoIT-fe</a>) on
          <a href="https://codepen.io">CodePen</a>.
        </p>
        <div class="note">
          <p>
            <strong>Увага</strong>: у перших двох методів є один істотний недолік, немає можливості змінити колір SVG
            зображення або додати йому анімацію. Вони ідеально підходять для статичної графіки.</p>
        </div>

        <!-- subsection -->
        <h3>Використання SVG як Object</h3>
        <p>Object - це якоюсь мірою оптимальний варіант для використання, якщо ви хочете мати можливість маніпулювати
          SVG, не вкладаючи його у свій HTML.
        </p>
        <p data-height="231" data-theme-id="30735" data-slug-hash="MvvBwM" data-default-tab="html,result"
          data-user="GoIT-fe" data-embed-version="2" data-pen-title="core-module-10-svg-as-object" class="codepen">See
          the Pen
          <a href="https://codepen.io/GoIT-fe/pen/MvvBwM/">core-module-10-svg-as-object</a> by GoIT (
          <a href="https://codepen.io/GoIT-fe">@GoIT-fe</a>) on
          <a href="https://codepen.io">CodePen</a>.
        </p>

        <!-- subsection -->
        <h3>Inline SVG</h3>
        <p>Можливо, кращим способом використати SVG є "Inline SVG". Тобто, ви можете відкрити SVG файл в текстовому
          редакторові, скопіювати SVG код і вставити його в HTML документ. Вставка вашого вбудованого SVG коду
          зберігатиме HTTP запит, але це означає, що зображення не кешується браузером. Це найпростіший спосіб
          маніпулювати, проте підтримка вбудованого SVG коду може бути болем.
        </p>
        <p>Зверніть увагу на теги svg, circle і path, останні два — це опис фігур усередині SVG, використовуючи XML.
          Зараз нам цікаво тільки те, що ми можемо для circle і path дати класи, до яких без проблем можна звернутися з
          CSS. У додаткових матеріалах є посилання для глибшого ознайомлення з внутрішнім устроєм SVG.</p>
        <p data-height="311" data-theme-id="30735" data-slug-hash="ZJJBYj" data-default-tab="html,result"
          data-user="GoIT-fe" data-embed-version="2" data-pen-title="core-module-10-inline-svg" class="codepen">See the
          Pen
          <a href="https://codepen.io/GoIT-fe/pen/ZJJBYj/">core-module-10-inline-svg</a> by GoIT (
          <a href="https://codepen.io/GoIT-fe">@GoIT-fe</a>) on
          <a href="https://codepen.io">CodePen</a>.
        </p>

        <p class="accent">Плюси:</p>
        <ul>
          <li>Inline SVG зберігає HTTP запит, отже, може скоротити час завантаження сторінки.
          </li>
          <li>Ви можете призначати класи та ідентифікатори елементам SVG і стилізувати їх за допомогою CSS, або у SVG.
          </li>
          <li>Inline SVG - єдиний підхід, що дозволяє використати інтерактивність CSS (наприклад: фокус) і анімації для
            SVG зображення.
          </li>
        </ul>

        <p class="accent">Мінуси:</p>
        <ul>
          <li>Цей метод підходить тільки у тому випадку, якщо ви використовуєте SVG тільки в одному місці. Дублювання
            призводить до зайвого споживання ресурсів.
          </li>
          <li>Додатковий SVG код збільшує розмір вашого HTML файлу.</li>
          <li>Браузер не може кешувати вбудований SVG, оскільки він кешируватиме звичайні зображення.
          </li>
        </ul>

        <!-- subsection -->
        <h3>SVG "спрайт"</h3>
        <p>Зараз ми навчимося використовувати SVG так, як це роблять у більшості випадків, якщо потрібна
          інтерактивність. SVG - це просто файл, усередині якого, на відміну від растрової графіки, описані фігури, які
          браузер відмалює. Усередині одного SVG ми можемо задати безліч різних груп фігур (symbol), після чого давши
          кожному символу унікальний id, звернутися до будь-якого з них усередині одного SVG файлу. Можливо, звучить
          дещо заплутано, але насправді все дуже просто.
        </p>
        <p class="accent">Переваги</p>
        <ul>
          <li>Один файл, завантажений браузером</li>
          <li>Може бути перетворений за допомогою CSS: колір, переходи, непрозорість тощо.</li>
          <li>Більш семантичний. Це просто посилання на зовнішній SVG файл і хеш</li>
          <li>Нема потреби в окремому CSS</li>
        </ul>
        <p>Складання SVG спрайту виходить за рамки цього уроку, але в додаткових матеріалах ви можете детально
          ознайомитися з методами складання такого спрайту. Зараз ми коротко розберемо, що ж відбувається.</p>
        <p>Отже, у SVG файлі ми можемо зберігати багато символів (SVG фігур, обернутих в symbol), це по суті й є SVG
          "спрайт". До кожного символу ми можемо звернутися по id. Результатом цього методу є те, що ви можете
          використати наступну розмітку в місцях, де раніше могли бути елементи span або i. Трюк тут — це тег
          <code>use</code> з атрибутом
          <code>href</code>, що вказує на зовнішній файл, з хешем, який є ідентифікатором символу, що міститься в цьому
          файлі.</p>
        <script type="text/plain" class="language-markup">
<svg>
  <use href="/path/to/svgdef.svg#your-icon"></use>
</svg>
          </script>

        <p class="accent">Розберімо приклад</p>
        <p>Для наочності ми вставили увесь SVG спрайт в документ (і задавши йому id, сховали), щоб заощадити вам час
          переходу пошуку коду SVG (адже цікаво, як він там усередині влаштований!).
        </p>
        <p>Отже, звичайний SVG, усередині набір XML тегів, svg і symbol, що описують увесь SVG спрайт цілком і кожну
          фігуру окремо. Кожному symbol заданий свій id. Нижче ми можемо використати атрибут href і звернутися до
          символу SVG через хеш (#) і його id. Увесь SVG розміщений в документі, тому немає імені SVG файлу перед хешем,
          якби цей SVG спрайт лежав поза документом, було б звернення на ім'я, а потім хеш і id символу. От як все
          просто!
        </p>
        <p data-height="277" data-theme-id="30735" data-slug-hash="QMMBpo" data-default-tab="html,result"
          data-user="GoIT-fe" data-embed-version="2" data-pen-title="core-module-10-adv-inline-svg" class="codepen">See
          the Pen
          <a href="https://codepen.io/GoIT-fe/pen/QMMBpo/">core-module-10-adv-inline-svg</a> by GoIT (
          <a href="https://codepen.io/GoIT-fe">@GoIT-fe</a>) on
          <a href="https://codepen.io">CodePen</a>.
        </p>

        <!-- subsection -->
        <h3>Підсумуємо</h3>
        <p>Якщо Ви хочете отримати максимальну віддачу від своїх SVG, використайте SVG спрайт. Як альтернативу Ви можете
          використати їх inline для збереження HTTP запиту, але тоді SVG не кешуватиметься. Якщо Ви просто хочете
          використати SVG, як і будь-яке інше зображення, використайте img або фонове зображення.
        </p>
        <div class="note">
          <p>"усередині svg" означає, що деякі прийоми працюють, але тільки якщо стилі розміщені безпосередньо у svg
            файлі усередині тега style.
          </p>
        </div>
        <table>
          <tr>
            <th></th>
            <th>Object</th>
            <th>Inline</th>
            <th>Img</th>
            <th>Background-image</th>
          </tr>
          <tr>
            <td>CSS Manipulation</td>
            <td>так</td>
            <td>так</td>
            <td>Усередині svg</td>
            <td>Усередині svg</td>
          </tr>
          <tr>
            <td>JS Manipulation</td>
            <td>так</td>
            <td>так</td>
            <td>ні</td>
            <td>ні</td>
          </tr>
          <tr>
            <td>SVG Animation</td>
            <td>так</td>
            <td>так</td>
            <td>так</td>
            <td>так</td>
          </tr>
          <tr>
            <td>Interactive SVG Animation</td>
            <td>так</td>
            <td>так</td>
            <td>ні</td>
            <td>ні</td>
          </tr>
        </table>
      </section>

      <!-- SECTION -->
      <section id="bem">
        <h2>Методологія BEM</h2>
        <div class="note">
          <p>There are only two hard problems in Computer Science: cache invalidation
            and naming things — Phil Karlton</p>
        </div>
        <p>Питання про те, як організувати стилі на невеликих сайтах, зазвичай не викликає головного болю. Ви пишете CSS
          або, можливо, навіть якийсь SASS. Ви скомпілюєте все це в єдину таблицю стилів з виробничими настройками SASS,
          а потім об'єднайте її, щоб отримати всі таблиці стилів з модулів в красивий акуратний пакет.</p>

        <p>Проте коли справа доходить до більших і складніших проєктів, правильна організація коду — це ключ до
          ефективності, принаймні, в цих трьох ситуаціях: він впливає на те, як довго вам треба писати код, скільки з
          цього коду вам доведеться писати, і скільки завантажуватиметься ваш вебсайт. Це стає особливо важливим, коли
          ви працюєте з групами користувачів, коли важлива висока продуктивність.</p>

        <p>Методологія Block, Element, Modifier (зазвичай звана BEM) - ця популярна домовленість про імена для класів в
          HTML і CSS, розроблена командою в Яндексі, її мета — допомогти розробникам краще зрозуміти взаємозв'язок між
          HTML і CSS в цьому проєкті. Методологія BEM допоможе вам створювати повторно використовувані компоненти і
          спільне використання коду в інтерфейсній розробці.
        </p>

        <!-- subsection -->
        <h3>Інші методології</h3>
        <p>Є безліч методологій, спрямованих на зниження навантаження на CSS, організацію співпраці між розробниками і
          підтримку великих кодових баз CSS.</p>
        <ul>
          <li>
            <a href="http://oocss.org/" target="_blank">
              <strong>OOCSS</strong>
            </a> - Розділення контейнера і вмісту за допомогою CSS об'єктів
          </li>
          <li>
            <a href="http://smacss.com/" target="_blank">
              <strong>SMACSS</strong>
            </a> - Стиль-настанова для написання CSS з п'ятьма категоріями для правил CSS
          </li>
          <li>
            <a href="http://suitcss.github.io/" target="_blank">
              <strong>SUITCSS</strong>
            </a> - Структуровані імена класів і значущі дефіси

          </li>
          <li>
            <a href="https://github.com/nemophrost/atomic-css" target="_blank">
              <strong>Atomic</strong>
            </a>
            - Руйнування стилів на атомарні або неділимі частини
          </li>
        </ul>

        <p>Незалежно від того, якій методології ви надаєте перевагу у своїх проєктах, ви зможете скористатися перевагами
          більш структурованого CSS і призначеного для користувача інтерфейсу. Деякі стилі менш строгі та гнучкіші, а
          інші легше зрозуміти й адаптувати в команді.</p>

        <!-- subsection -->
        <h3>Чому саме BEM?</h3>
        <p>Саме поняття
          <code>BEM</code> — не лише метод іменування селекторів, але парадигма сприйняття проєкту як набору сутностей
          (блоки, елементи, модифікатори). Можна виділити наступні переваги:
        </p>
        <ul>
          <li>Автоматичне документування</li>
          <li>Імітація простору імен (простота і безпека модифікації).</li>
          <li>Відсутність залежності від DOM структури.</li>
          <li>Проєктне перевикористання блоків.</li>
          <li>Кроспроєктне перевикористання блоків.</li>
        </ul>
        <p>BEM сьогодні є найпопулярнішою методологією. Він менш заплутаний і надає нам хорошу архітектуру з
          термінологією, що легко впізнається.
        </p>

        <!-- subsection -->
        <h3>Блоки, Елементи та Модифікатори</h3>
        <p>BEM є абревіатурою ключових елементів методології - Block, Element і Modifier. Абсолютно все будується на
          розумінні цих трьох ключових понять.</p>

        <div class="note">
          <p>Використовуючи BEM, ми повністю (чи частково, в контекстних модифікаторах) відмовляємося від каскадності
            CSS. Більше немає селекторів виду
            <code>ul&gt;li&gt;a</code>, звернення до HTML тегів відбувається тільки через класи.
          </p>
        </div>

        <!-- sub-subsection -->
        <h4>BEM блок</h4>
        <p>Блок — це самостійна частина сторінки.</p>
        <p>Автономна суть, яка має сенс сама по собі. Абстракція верхнього рівня нового компонента. Блок слід розглядати
          як батька для елементів. Блоки можуть бути вкладеними і взаємодіяти один з одним, але семантично вони
          залишаються рівними. Немає пріоритету або ієрархії. Блок можна поставити в іншу частину сторінки, і він матиме
          сенс. Приміром, блоком може бути галерея, стаття, віджет сайдбара, сам сайдбар, навігація, форма тощо. Тобто,
          блок - це незалежний компонент.</p>

        <ul>
          <li>Назва класу має бути простою і короткою, імена блоків можуть складатися з латинських букв, цифр і тире.
          </li>
          <li>Назва класу повинна відповідати на питання "Що це"?
          </li>
          <li>Назва не повинна відповідати на питання "Який вигляд має"?</li>
        </ul>

        <p data-height="319" data-theme-id="30735" data-slug-hash="GvvVva" data-default-tab="html,result"
          data-user="GoIT-fe" data-embed-version="2" data-pen-title="core-module-10-bem-block" class="codepen">See the
          Pen
          <a href="https://codepen.io/GoIT-fe/pen/GvvVva/">core-module-10-bem-block</a> by GoIT (
          <a href="https://codepen.io/GoIT-fe">@GoIT-fe</a>) on
          <a href="https://codepen.io">CodePen</a>.
        </p>

        <p>Блоки можна і треба вкладати один в одного.</p>
        <ul>
          <li>Немає обмежень на вкладення блоків, окрім здорового глузду.</li>
          <li>Ніякої додаткової специфіки вкладені блоки не мають.</li>
        </ul>

        <!-- sub-subsection -->
        <h4>BEM елемент</h4>
        <p>
          <strong>BEM елемент</strong> - це невід'ємна частина блоку, яка не має окремого значення і семантично
          прив'язана до її блоку. Приміром, елемент меню, заголовок або текст в статті, картинка галереї тощо.</p>
        <ul>
          <li>Назва класу формується з назви блоку з додаванням __ і назви елементу.
          </li>
          <li>Назва класу має бути простою і короткою.</li>
          <li>Назва класу повинна відповідати на питання "Що це"?</li>
          <li>Назва не повинна відповідати на питання "Який вигляд має"? </li>
        </ul>
        <p>Додаймо заголовок, картинку і текст до нашої статті. Поза статтею цей контент не має ніякого сенсу, він
          прив'язаний до статті, отже, це елементи.
        </p>
        <p data-height="497" data-theme-id="30735" data-slug-hash="qXXexy" data-default-tab="html,result"
          data-user="GoIT-fe" data-embed-version="2" data-pen-title="core-module-10-bem-element" class="codepen">See the
          Pen
          <a href="https://codepen.io/GoIT-fe/pen/qXXexy/">core-module-10-bem-element</a> by GoIT (
          <a href="https://codepen.io/GoIT-fe">@GoIT-fe</a>) on
          <a href="https://codepen.io">CodePen</a>.
        </p>

        <p>Чому не можна просто так розташовувати елемент поза блоком:</p>
        <ul>
          <li>втрачається логіка розмітки</li>
          <li>складно стилізувати елементи, які можуть виявитися де завгодно (float, абс. позиціювання і деякі інші
            стилі такого елементу можуть "зламати" верстання)</li>
        </ul>

        <div class="note">
          <p>Елементів може не бути. Не у усіх блоків мають бути елементи: кнопка - завжди BEM- блок, але BEM- елементи
            у неї усередині зустрічаються відносно рідко. Хіба що іконка.
          </p>
        </div>

        <!-- sub-subsection -->
        <h4>Як відрізнити BEM-блок і BEM-елемент</h4>
        <p>Просто поставте собі питання: "Ця сутність може знадобитися мені окремо, сама по собі? Чи вона потрібна
          тільки усередині її батька"? Якщо потрібна окремо - це BEM-блок, якщо тільки усередині батька - це BEM-
          елемент.</p>
        <p>У дійсно сумнівних випадках робіть вибір на користь BEM-блоку.</p>
        <p>На усіх проєктах (окрім зовсім вже крихітних або таких, що мають гарантовано нульову можливість модифікації)
          є фрагменти дизайну, які мудро завжди робити BEM-блоками унаслідок високої вірогідності повторення.</p>

        <p>Деякі фрагменти інтерфейсу - завжди BEM-блоки:</p>
        <ul>
          <li>Кнопка (будь-які кнопки)</li>
          <li>Блоки усередині форм (блок для текстового поля, блок для радіокнопки і тому подібне)</li>
          <li>Пагінація</li>
          <li>Таби</li>
          <li>Лейбли (мітки) </li>
          <li>Соціальні посилання</li>
          <li>"Лайк" з лічильником</li>
        </ul>

        <!-- sub-subsection -->
        <h4>BEM модифікатор</h4>
        <p>Модифікатор - додатковий клас для зміни оформлення або поведінки. Прапор на блоці або елементі.
          Використовується для зміни зовнішнього вигляду, поведінки або стану. Приміром, вибрана кнопка, ефект ховера,
          вибраний кастомний чекбокс, зміна розмірів або кольору.</p>
        <ul>
          <li>Назва класу формується з назви блоку/елементу з додаванням -- і назви модифікатора.</li>
          <li>Назва має бути простою і короткою.</li>
          <li>Назва класу може відповідати на питання "Що це"?, "Що міняється"?, "Чим відрізняється від інших"?</li>
        </ul>

        <div class="note">
          <p>Клас модифікатор ніколи не повинен використовуватися самостійно, але завжди тільки з тим класом, який він
            модифікує.</p>
        </div>

        <p>Додамо до нашої статті ще кнопку, після чого створимо ще 2 таких же статті, але в кожній колір кнопки
          відрізнятиметься. Крім того, ми ще додамо модифікатор для ефекту ховера.</p>
        <p data-height="555" data-theme-id="30735" data-slug-hash="BddXbj" data-default-tab="result" data-user="GoIT-fe"
          data-embed-version="2" data-pen-title="core-module-10-bem-modifier" class="codepen">See the Pen
          <a href="https://codepen.io/GoIT-fe/pen/BddXbj/">core-module-10-bem-modifier</a>
          by GoIT (
          <a href="https://codepen.io/GoIT-fe">@GoIT-fe</a>) on
          <a href="https://codepen.io">CodePen</a>.
        </p>

        <h4>Змішування</h4>
        <p>Змішування- комбінування на одному тегу класів BEM блоку і BEM елементу. Комбінація можлива у будь-якому
          поєднанні: BEM блок + BEM елемент, BEM блок + BEM блок, BEM елемент + BEM елемент. Цей підхід дозволяє:</p>

        <ul>
          <li>Додати деякі стильові властивості, необхідні тільки в місці додавання (використання модифікатора
            нераціональне). Наприклад, для
            <code>.btn</code> усередині .page-header потрібний зовнішній лівий відступ в
            <code>30px</code>. Можна дописати для тега з .btn додатковий клас
            <code>.page-header__btn</code> і дати відступ за допомогою цього селектора. Це нормальна практика, її можна
            використати.</li>
          <li>Об'єднати стилізацію 2-х і більше блоків. Наприклад, для
            <code>.article</code> і для
            <code>.page-footer__section</code> шрифтові властивості однакові. Можна винести визначення шрифтових
            властивостей в новий блок
            <code>.text</code> і дописати цей клас
            <code>.article</code> і
            <code>.page-footer__section</code>. Цей підхід надмірно пов'язує частини сторінки (нагадує OOCSS і
            клас-хелпер), не робіть так.</li>
          <li>Обійтися без тега-обгортки з селектором, що додається. Наприклад сторінка каталогу, 7+ товарів в потоці,
            кожен товар -
            <code>.product</code>, але кожному елементу потоку потрібні стильові властивості комірок модульної сітки (по
            якій побудовано потокове виведення). Можна додати для
            <code>.product</code> клас комірки модульної сітки, щоб не робити обгортку з цим класом. Це відгукнеться
            конфліктом відступів/розмірів, не змішуйте на одному тегу класи обгортки і вмісту.</li>
        </ul>

        <!-- sub-subsection -->
        <h3>Вкладеність блоків і елементів</h3>
        <p>
          <strong>Блок</strong> - це просто розділ документу, такий як
          <code>header</code>,
          <code>footer</code>,
          <code>sidebar</code> тощо. Блоки можуть містити інші блоки. Наприклад, блок заголовка може також містити блоки
          логотипу, навігації і форми пошуку тощо, які у свою чергу можуть містити елементи або інші блоки.</p>

        <p>Важливо розуміти розділення ієрархії HTML документу і ієрархії BEM класів. При HTML розмітці, BEM блок може
          бути вкладений в елемент, як тег у тегові, але при цьому він не є елементом блоку або елементом елементу.
        </p>
        <div class="note">
          <p>Просте правило: максимальний запис BEM класу може мати лише такий вигляд:
            <code>.block__element--modifier</code>. Якщо у вас є множинні імена блоків, елементів або модифікаторів при
            записі класу, ви помилилися.</p>
        </div>

        <p>Використовуючи наші статті з попередніх прикладів, створимо секцію статей. Секція це блок, у нього є елементи
          заголовка, тіла та items (у яких розташовуватиметься довільний контент). У item секції поміщаємо наші статті,
          все добре працює. Зверніть увагу, що у статей немає ширини, її ми вказали елементам секції. За методологією
          BEM, блок не може мати зовнішніх відступів (і іноді ширини), щоб не порушувати зовнішню геометрію
          (відштовхнути інші блоки при зміні свого розташування на сторінці).</p>
        <p data-height="709" data-theme-id="30735" data-slug-hash="jLGEYr" data-default-tab="result" data-user="GoIT-fe"
          data-embed-version="2" data-pen-title="core-module-10-bem-hierarchy" class="codepen">See the Pen
          <a href="https://codepen.io/GoIT-fe/pen/jLGEYr/">core-module-10-bem-hierarchy</a>
          by GoIT (
          <a href="https://codepen.io/GoIT-fe">@GoIT-fe</a>) on
          <a href="https://codepen.io">CodePen</a>.
        </p>

        <!-- sub-subsection -->
        <h3>Висновок</h3>
        <p>Повторимо і підіб'ємо підсумки. Методологія BEM спонукає дизайнерів і розробників думати про вебсайт як про
          набір багаторазових блоків компонентів, які можна змішувати і зіставляти для створення інтерфейсів.</p>
        <p class="accent">Плюси BEM</p>
        <ul>
          <li>
            <strong>Модульність</strong> - стилі блоків ніколи не залежать від інших елементів на сторінці, тому ви
            ніколи не зіткнетеся з каскадом. Ви також отримуєте можливість використати одні блоки в різних проєктах.
          </li>
          <li>
            <strong>Повторне використання</strong> - складаючи незалежні блоки по-різному і використовуючи їх розумно,
            зменшується кількість коду CSS, який вам треба буде підтримувати. Ви можете створити бібліотеку блоків, що
            зробить ваш CSS супер ефективним.
          </li>
          <li>
            <strong>Структура CSS</strong> - методологія BEM дає вашому CSS коду міцну структуру, яка залишається
            простою і зрозумілою.
          </li>
        </ul>
        <div class="note">
          <p>Щоб навчитися використати BEM правильно, потрібно час і практику, багато практики. Треба більш глибоко
            дивитися на структуру сторінки, опрацьовувати варіанти та зв'язки між блоками й елементами. У додаткових
            матеріалах є посилання на статті, в яких наводяться додаткові приклади.</p>
        </div>
      </section>

      <!-- SECTION -->
      <section id="resources">
        <h2>Додаткові матеріали</h2>
        <ul>
          <li>
            <a href="https://www.w3.org/wiki/Graceful_degradation_versus_progressive_enhancement" target="_blank">Стаття
              W3C про GD і PE</a>
          </li>
          <li>
            <a href="https://css-tricks.com/snippets/css/retina-display-media-query/" target="_blank">Список медіаправил
              для Retina екранів</a>
          </li>
          <li>
            <a href="https://svgontheweb.com/" target="_blank">Великий ресурс, присвячений SVG </a>
          </li>
          <li>
            <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial" target="_blank">Повне керівництво по SVG
              на MDN</a>
          </li>
          <li>
            <a href="https://github.com/yoksel/common-words" target="_blank">Довідник імен класів
            </a>
          </li>
          <li>
            <a href="https://css-tricks.com/bem-101/" target="_blank">BEM на CSS - tricks</a>
          </li>
          <li>
            <a href="https://www.sitepoint.com/css-architecture-block-element-modifier-bem/" target="_blank">Стаття про
              BEM філософії на sitepoint</a>
          </li>
        </ul>
      </section>
    </article>
    <!-- ===== #page-navigator ======  -->
    <a href="#main-nav" class="to-page-nav"></a>
    <!-- ===== #end page-navigator =====  -->
  </div>
</body>

</html>